@page "/"
@implements IAsyncDisposable
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer

@using Microsoft.JSInterop
@using Microsoft.AspNetCore.SignalR.Client
@using Tornado.Services
@using Tornado.Components.Describe
@inject IConfiguration Configuration
@inject HttpClient Http
@inject IJSRuntime Js
@inject NavigationManager Navigation
@inject LayoutState LayoutState

@if (!string.IsNullOrWhiteSpace(LoadError))
{
    <section class="card">
        <div class="error">@LoadError</div>
    </section>
}

@if (!string.IsNullOrWhiteSpace(ActionMessage))
{
    <section class="card">
        <div class="meta">@ActionMessage</div>
    </section>
}

<section class="card table-card full-width hierarchy-card">
    <div class="table-header">
        <div>
            <h2>Workload Hierarchy</h2>
        </div>
    </div>
    <div class="table-wrap">
        <table class="data-table hierarchy-table">
            <thead>
            <tr>
                <th class="col-type">Type</th>
                <th class="col-name">Name</th>
                <th class="col-namespace">Namespace</th>
                <th class="col-detail">Details</th>
                <th class="col-related">Related</th>
                <th class="col-action">Actions</th>
            </tr>
            </thead>
            <tbody>
            @foreach (var workload in VisibleWorkloads)
            {
                var key = GetWorkloadKey(workload);
                var isSelected = SelectedWorkloadKey == key;
                var services = GetWorkloadServices(workload).ToList();
                var pods = GetWorkloadPods(workload).ToList();
                var ingresses = GetWorkloadIngresses(services).ToList();
                <tr class="row-workload @(isSelected ? "row-selected" : "")" @onclick="() => ToggleWorkload(workload)">
                    <td>
                        <span class="disclosure">@(isSelected ? "v" : ">")</span>
                        <span class="tag tag-clickable @GetWorkloadTagClass(workload.Kind)"
                              @onclick:stopPropagation
                              @onclick="() => OpenDescribe(workload.Kind, workload.Namespace, workload.Name)">
                            @workload.Kind
                        </span>
                    </td>
                    <td>@workload.Name</td>
                    <td>@workload.Namespace</td>
                    <td>@FormatWorkloadStatus(workload)</td>
                    <td>@FormatRelatedSummary(services.Count, pods.Count, ingresses.Count)</td>
                    <td>
                        <button class="ghost danger pill-action"
                                disabled="@Restarting.Contains(key)"
                                @onclick:stopPropagation
                                @onclick="() => RestartWorkload(workload)">
                            @(Restarting.Contains(key) ? "Restarting" : "Restart")
                        </button>
                    </td>
                </tr>

                @if (isSelected)
                {
                    foreach (var pod in pods)
                    {
                        <tr class="row-child row-pod">
                            <td>
                                <span class="tag tag-pod tag-clickable"
                                      @onclick:stopPropagation
                                      @onclick="() => OpenDescribe(ResourceKindPod, pod.Namespace, pod.Name)">
                                    Pod
                                </span>
                            </td>
                            <td>@pod.Name</td>
                            <td>@pod.Namespace</td>
                            <td>
                                <span class="status">
                                    <span class="status-badge @GetStatusBadgeClass(pod.Status)">
                                        @GetStatusBadgeLabel(pod.Status)
                                    </span>
                                    <span>@pod.Status</span>
                                </span>
                                <span class="status-meta">· @pod.Ready ready · @pod.Age</span>
                            </td>
                            <td>@($"Node {pod.Node}")</td>
                            <td>
                                <button class="ghost pill-action" @onclick:stopPropagation @onclick="() => OpenLogs(pod)">
                                    Logs
                                </button>
                            </td>
                        </tr>
                    }

                    foreach (var service in services)
                    {
                        <tr class="row-child row-service">
                            <td>
                                <span class="tag tag-service tag-clickable"
                                      @onclick:stopPropagation
                                      @onclick="() => OpenDescribe(ResourceKindService, service.Namespace, service.Name)">
                                    Service
                                </span>
                            </td>
                            <td>@service.Name</td>
                            <td>@service.Namespace</td>
                            <td>@($"{service.Type} · {FormatPorts(service.Ports)}")</td>
                            <td>@FormatLabels(service.Selector)</td>
                            <td>
                                @if (!string.IsNullOrWhiteSpace(GetServiceOpenUrl(service)))
                                {
                                    <a class="button-link link-external pill-action" href="@GetServiceOpenUrl(service)" target="_blank" rel="noreferrer">Open</a>
                                }
                            </td>
                        </tr>
                    }

                    foreach (var ingress in ingresses)
                    {
                        <tr class="row-child row-ingress">
                            <td>
                                <span class="tag tag-ingress tag-clickable"
                                      @onclick:stopPropagation
                                      @onclick="() => OpenDescribe(ResourceKindIngress, ingress.Namespace, ingress.Name)">
                                    Ingress
                                </span>
                            </td>
                            <td>@ingress.Name</td>
                            <td>@ingress.Namespace</td>
                            <td>@FormatIngressRules(ingress.Rules)</td>
                            <td>@(string.IsNullOrWhiteSpace(ingress.ClassName) ? "-" : ingress.ClassName)</td>
                            <td>
                                @if (!string.IsNullOrWhiteSpace(GetIngressOpenUrl(ingress)))
                                {
                                    <a class="button-link link-external pill-action" href="@GetIngressOpenUrl(ingress)" target="_blank" rel="noreferrer">Open</a>
                                }
                            </td>
                        </tr>
                    }

                    if (services.Count == 0 && pods.Count == 0 && ingresses.Count == 0)
                    {
                        <tr class="row-child">
                            <td colspan="6" class="muted">No related services, pods, or ingresses found.</td>
                        </tr>
                    }
                }
            }
            </tbody>
        </table>
    </div>
</section>

<section class="overview-grid">
    <div class="card mini-card">
        <h3>Nodes <span class="mini-count">@Nodes.Count</span></h3>
        <div class="mini-table">
            @foreach (var node in Nodes)
            {
                <div class="@GetNodeRowClass(node)"
                     @onclick="() => OpenDescribe(ResourceKindNode, string.Empty, node.Name)">
                    <span>@node.Name</span>
                    <span>@(string.IsNullOrWhiteSpace(node.ExternalIp) ? node.InternalIp : node.ExternalIp)</span>
                </div>
            }
        </div>
    </div>

    <div class="card mini-card">
        <h3>Pods <span class="mini-count">@VisiblePods.Count</span></h3>
        <div class="mini-table">
            @foreach (var pod in VisiblePods)
            {
                <div class="@GetMiniRowClass(ResourceTypePod, pod.Namespace, pod.Name, IsRelatedPod(pod))"
                     @onmouseenter="() => HandleHover(ResourceTypePod, pod.Namespace, pod.Name)"
                     @onclick="() => OpenDescribe(ResourceKindPod, pod.Namespace, pod.Name)"
                     @onmouseleave="ClearHover">
                    <span>@pod.Name</span>
                    <span class="status">
                        <span class="status-badge @GetStatusBadgeClass(pod.Status)">
                            @GetStatusBadgeLabel(pod.Status)
                        </span>
                        <span>@pod.Status</span>
                    </span>
                </div>
            }
        </div>
    </div>

    <div class="card mini-card">
        <h3>Workloads <span class="mini-count">@VisibleWorkloads.Count</span></h3>
        <div class="mini-table">
            @foreach (var workload in VisibleWorkloads)
            {
                <div class="@GetMiniRowClass(ResourceTypeWorkload, workload.Namespace, workload.Name, IsRelatedWorkload(workload))"
                     @onmouseenter="() => HandleHover(ResourceTypeWorkload, workload.Namespace, workload.Name)"
                     @onclick="() => OpenDescribe(workload.Kind, workload.Namespace, workload.Name)"
                     @onmouseleave="ClearHover">
                    <span>@workload.Name</span>
                    <span>@FormatWorkloadStatus(workload)</span>
                </div>
            }
        </div>
    </div>

    <div class="card mini-card">
        <h3>Services <span class="mini-count">@VisibleServices.Count</span></h3>
        <div class="mini-table">
            @foreach (var service in VisibleServices)
            {
                var serviceUrl = GetServiceOpenUrl(service);
                <div class="@GetMiniRowClass(ResourceTypeService, service.Namespace, service.Name, IsRelatedService(service))"
                     @onmouseenter="() => HandleHover(ResourceTypeService, service.Namespace, service.Name)"
                     @onclick="() => OpenDescribe(ResourceKindService, service.Namespace, service.Name)"
                     @onmouseleave="ClearHover">
                    <span>
                        @if (!string.IsNullOrWhiteSpace(serviceUrl))
                        {
                            <a class="mini-link link-external"
                               href="@serviceUrl"
                               target="_blank"
                               rel="noreferrer"
                               @onclick:stopPropagation>
                                @service.Name
                            </a>
                        }
                        else
                        {
                            @service.Name
                        }
                    </span>
                    <span>@FormatPorts(service.Ports)</span>
                </div>
            }
        </div>
    </div>

    <div class="card mini-card">
        <h3>Ingresses <span class="mini-count">@VisibleIngresses.Count</span></h3>
        <div class="mini-table">
            @foreach (var ingress in VisibleIngresses)
            {
                var ingressUrl = GetIngressOpenUrl(ingress);
                <div class="@GetMiniRowClass(ResourceTypeIngress, ingress.Namespace, ingress.Name, IsRelatedIngress(ingress))"
                     @onmouseenter="() => HandleHover(ResourceTypeIngress, ingress.Namespace, ingress.Name)"
                     @onclick="() => OpenDescribe(ResourceKindIngress, ingress.Namespace, ingress.Name)"
                     @onmouseleave="ClearHover">
                    <span>
                        @if (!string.IsNullOrWhiteSpace(ingressUrl))
                        {
                            <a class="mini-link link-external"
                               href="@ingressUrl"
                               target="_blank"
                               rel="noreferrer"
                               @onclick:stopPropagation>
                                @ingress.Name
                            </a>
                        }
                        else
                        {
                            @ingress.Name
                        }
                    </span>
                    <span>@FormatIngressHost(ingress)</span>
                </div>
            }
        </div>
    </div>
</section>

@if (IsLogModalOpen)
{
    <div class="modal-backdrop" @onclick="CloseLogs">
        <div class="modal" @onclick:stopPropagation>
            <div class="modal-header">
                <div>
                    <h3>@LogTitle</h3>
                    <div class="meta">@LogSubtitle</div>
                </div>
                <button class="ghost" @onclick="CloseLogs">Close</button>
            </div>
            <div class="modal-body">
                <div class="log-controls">
                    <label class="control-label">
                        Filter
                        <input type="text" placeholder="e.g. error" @bind="LogFilter" @bind:event="oninput" @bind:after="OnLogFilterChanged" />
                    </label>
                </div>
                @if (LogLoading)
                {
                    <div class="meta">Loading logs...</div>
                }
                else if (!string.IsNullOrWhiteSpace(LogError))
                {
                    <div class="error">@LogError</div>
                }
                else
                {
                    <pre>@((MarkupString)(LogContent ?? string.Empty))</pre>
                }
            </div>
        </div>
    </div>
}

<DescribeModal IsOpen="@IsDescribeModalOpen"
               Kind="@DescribeKind"
               Namespace="@DescribeNamespace"
               Name="@DescribeName"
               Pods="@Pods"
               OnClose="CloseDescribe"
               OnOpenResource="OpenDescribeFromRef"
               OnOpenLogs="OpenLogsFromRef" />

@code {
    private readonly HashSet<string> Restarting = new();
    private List<ServiceSummary> Services { get; set; } = new();
    private List<WorkloadSummary> Workloads { get; set; } = new();
    private List<IngressSummary> Ingresses { get; set; } = new();
    private List<PodSummary> Pods { get; set; } = new();
    private List<NodeSummary> Nodes { get; set; } = new();

    private bool IsLoading { get; set; }
    private string? LoadError { get; set; }
    private string? ActionMessage { get; set; }
    private DateTimeOffset? LastUpdatedAt { get; set; }
    private string? SelectedWorkloadKey { get; set; }
    private const int LogRefreshSeconds = 1;
    private string? HoveredType { get; set; }
    private string? HoveredNamespace { get; set; }
    private string? HoveredName { get; set; }
    private bool _scrollRelationsPending;
    private DateTimeOffset _lastInteractionAt = DateTimeOffset.UtcNow;
    private HubConnection? _clusterHub;

    private CancellationTokenSource? LastUpdatedCts { get; set; }

    private bool IsLogModalOpen { get; set; }
    private bool LogLoading { get; set; }
    private string? LogTitle { get; set; }
    private string? LogSubtitle { get; set; }
    private string? LogContent { get; set; }
    private string? LogContentRaw { get; set; }
    private string? LogError { get; set; }
    private string? LogFilter { get; set; }
    private CancellationTokenSource? LogFollowCts { get; set; }

    private bool IsDescribeModalOpen { get; set; }
    private string? DescribeKind { get; set; }
    private string? DescribeNamespace { get; set; }
    private string? DescribeName { get; set; }

    protected override async Task OnInitializedAsync()
    {
        LayoutState.SetHeaderContent(HeaderContent);
        await RefreshAll();
        await StartLiveUpdatesAsync();
        UpdateLastUpdatedClock();
    }

    private async Task RefreshAll()
    {
        MarkInteraction();
        IsLoading = true;
        LoadError = null;
        ActionMessage = null;

        try
        {
            var podsTask = LoadPods();
            var servicesTask = LoadServices();
            var workloadsTask = LoadWorkloads();
            var ingressesTask = LoadIngresses();
            var nodesTask = LoadNodes();

            await Task.WhenAll(podsTask, servicesTask, workloadsTask, ingressesTask, nodesTask);

            LastUpdatedAt = DateTimeOffset.Now;
            LayoutState.SetHeaderContent(HeaderContent);
        }
        catch (Exception ex)
        {
            LoadError = ex.Message;
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task LoadPods()
    {
        var data = await GetFromApiAsync<List<PodSummary>>("/cluster/pods");
        if (data is not null)
        {
            Pods = data;
        }
    }

    private async Task LoadServices()
    {
        var data = await GetFromApiAsync<List<ServiceSummary>>("/cluster/services");
        if (data is not null)
        {
            Services = data;
        }
    }

    private async Task LoadWorkloads()
    {
        var data = await GetFromApiAsync<List<WorkloadSummary>>("/cluster/workloads");
        if (data is not null)
        {
            Workloads = data;
        }
    }

    private async Task LoadIngresses()
    {
        var data = await GetFromApiAsync<List<IngressSummary>>("/cluster/ingresses");
        if (data is not null)
        {
            Ingresses = data;
        }
    }

    private async Task LoadNodes()
    {
        var data = await GetFromApiAsync<List<NodeSummary>>("/cluster/nodes");
        if (data is not null)
        {
            Nodes = data;
        }
    }

    private async Task StartLiveUpdatesAsync()
    {
        if (_clusterHub is not null)
        {
            return;
        }

        var hubUri = BuildRequestUri(ClusterHub.HubRoute);
        _clusterHub = new HubConnectionBuilder()
            .WithUrl(hubUri)
            .WithAutomaticReconnect()
            .Build();

        _clusterHub.On<ClusterSnapshot>(ClusterHub.ClusterUpdatedEvent, snapshot =>
        {
            ApplySnapshot(snapshot);
        });

        _clusterHub.Reconnected += async _ =>
        {
            await RequestSnapshotAsync();
        };

        await _clusterHub.StartAsync();
        await RequestSnapshotAsync();
    }

    private void ApplySnapshot(ClusterSnapshot snapshot)
    {
        Pods = snapshot.Pods.ToList();
        Services = snapshot.Services.ToList();
        Workloads = snapshot.Workloads.ToList();
        Ingresses = snapshot.Ingresses.ToList();
        Nodes = snapshot.Nodes.ToList();
        LastUpdatedAt = DateTimeOffset.Now;
        LayoutState.SetHeaderContent(HeaderContent);
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task RequestSnapshotAsync()
    {
        if (_clusterHub is null)
        {
            return;
        }

        try
        {
            var snapshot = await _clusterHub.InvokeAsync<ClusterSnapshot?>("GetSnapshot");
            if (snapshot is not null)
            {
                ApplySnapshot(snapshot);
            }
        }
        catch (Exception)
        {
            // Ignore transient hub errors; fallback refresh still works.
        }
    }

    private const string ResourceTypeWorkload = "workload";
    private const string ResourceTypeService = "service";
    private const string ResourceTypePod = "pod";
    private const string ResourceTypeIngress = "ingress";
    private const string ResourceTypeNode = "node";
    private const string ResourceKindPod = "Pod";
    private const string ResourceKindService = "Service";
    private const string ResourceKindIngress = "Ingress";
    private const string ResourceKindNode = "Node";

    private bool HasHover => !string.IsNullOrWhiteSpace(HoveredType);

    private void SetHover(string type, string ns, string name)
    {
        HoveredType = type;
        HoveredNamespace = ns;
        HoveredName = name;
    }

    private Task HandleHover(string type, string ns, string name)
    {
        MarkInteraction();
        SetHover(type, ns, name);
        _scrollRelationsPending = true;
        return Task.CompletedTask;
    }

    private void ClearHover()
    {
        HoveredType = null;
        HoveredNamespace = null;
        HoveredName = null;
        _scrollRelationsPending = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollRelationsPending)
        {
            _scrollRelationsPending = false;
            await Js.InvokeVoidAsync("tornadoScrollRelations");
        }
    }

    private void OpenDescribe(string kind, string ns, string name)
    {
        MarkInteraction();
        DescribeKind = kind;
        DescribeNamespace = ns;
        DescribeName = name;
        IsDescribeModalOpen = true;
    }

    private Task OpenDescribeFromRef(ResourceRef reference)
    {
        OpenDescribe(reference.Kind, reference.Namespace, reference.Name);
        return Task.CompletedTask;
    }

    private async Task OpenLogsFromRef(ResourceRef reference)
    {
        if (!string.Equals(reference.Kind, "Pod", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        CloseDescribe();
        var pod = Pods.FirstOrDefault(item =>
            string.Equals(item.Namespace, reference.Namespace, StringComparison.Ordinal) &&
            string.Equals(item.Name, reference.Name, StringComparison.Ordinal));

        if (pod is not null)
        {
            await OpenLogs(pod);
            return;
        }

        var placeholder = new PodSummary(reference.Namespace, reference.Name, "", "Unknown", "0/0", 0, "", new Dictionary<string, string>());
        await OpenLogs(placeholder);
    }

    private void CloseDescribe()
    {
        MarkInteraction();
        IsDescribeModalOpen = false;
        DescribeKind = null;
        DescribeNamespace = null;
        DescribeName = null;
    }

    private bool IsHovered(string type, string ns, string name)
        => string.Equals(HoveredType, type, StringComparison.Ordinal) &&
           string.Equals(HoveredNamespace, ns, StringComparison.Ordinal) &&
           string.Equals(HoveredName, name, StringComparison.Ordinal);

    private string GetMiniRowClass(string type, string ns, string name, bool isRelated)
    {
        if (IsHovered(type, ns, name))
        {
            return "mini-row is-hovered";
        }

        if (HasHover && isRelated)
        {
            return "mini-row is-related";
        }

        return "mini-row";
    }

    private string GetNodeRowClass(NodeSummary node)
    {
        if (IsRelatedNode(node))
        {
            return "mini-row is-related";
        }

        return "mini-row";
    }

    private WorkloadSummary? GetHoveredWorkload()
        => HoveredType == ResourceTypeWorkload
            ? VisibleWorkloads.FirstOrDefault(w => w.Namespace == HoveredNamespace && w.Name == HoveredName)
            : null;

    private ServiceSummary? GetHoveredService()
        => HoveredType == ResourceTypeService
            ? VisibleServices.FirstOrDefault(s => s.Namespace == HoveredNamespace && s.Name == HoveredName)
            : null;

    private PodSummary? GetHoveredPod()
        => HoveredType == ResourceTypePod
            ? VisiblePods.FirstOrDefault(p => p.Namespace == HoveredNamespace && p.Name == HoveredName)
            : null;

    private IngressSummary? GetHoveredIngress()
        => HoveredType == ResourceTypeIngress
            ? VisibleIngresses.FirstOrDefault(i => i.Namespace == HoveredNamespace && i.Name == HoveredName)
            : null;


    private bool IsRelatedWorkload(WorkloadSummary workload)
    {
        if (!HasHover)
        {
            return false;
        }

        var service = GetHoveredService();
        if (service is not null)
        {
            return workload.Namespace == service.Namespace &&
                   LabelsMatch(service.Selector, workload.Labels);
        }

        var pod = GetHoveredPod();
        if (pod is not null)
        {
            return workload.Namespace == pod.Namespace &&
                   LabelsMatch(workload.Labels, pod.Labels);
        }

        var ingress = GetHoveredIngress();
        if (ingress is not null)
        {
            return IsIngressRelatedToWorkload(ingress, workload);
        }

        return false;
    }

    private bool IsRelatedService(ServiceSummary service)
    {
        if (!HasHover)
        {
            return false;
        }

        var workload = GetHoveredWorkload();
        if (workload is not null)
        {
            return service.Namespace == workload.Namespace &&
                   LabelsMatch(service.Selector, workload.Labels);
        }

        var pod = GetHoveredPod();
        if (pod is not null)
        {
            return service.Namespace == pod.Namespace &&
                   LabelsMatch(service.Selector, pod.Labels);
        }

        var ingress = GetHoveredIngress();
        if (ingress is not null)
        {
            return ingress.Namespace == service.Namespace &&
                   ingress.Rules.Any(rule => string.Equals(rule.Backend.ServiceName, service.Name, StringComparison.Ordinal));
        }

        return false;
    }

    private bool IsRelatedPod(PodSummary pod)
    {
        if (!HasHover)
        {
            return false;
        }

        var workload = GetHoveredWorkload();
        if (workload is not null)
        {
            return pod.Namespace == workload.Namespace &&
                   LabelsMatch(workload.Labels, pod.Labels);
        }

        var service = GetHoveredService();
        if (service is not null)
        {
            return pod.Namespace == service.Namespace &&
                   LabelsMatch(service.Selector, pod.Labels);
        }

        var ingress = GetHoveredIngress();
        if (ingress is not null)
        {
            return IsIngressRelatedToPod(ingress, pod);
        }

        return false;
    }

    private bool IsRelatedIngress(IngressSummary ingress)
    {
        if (!HasHover)
        {
            return false;
        }

        var workload = GetHoveredWorkload();
        if (workload is not null)
        {
            return IsIngressRelatedToWorkload(ingress, workload);
        }

        var service = GetHoveredService();
        if (service is not null)
        {
            return ingress.Namespace == service.Namespace &&
                   ingress.Rules.Any(rule => string.Equals(rule.Backend.ServiceName, service.Name, StringComparison.Ordinal));
        }

        var pod = GetHoveredPod();
        if (pod is not null)
        {
            return IsIngressRelatedToPod(ingress, pod);
        }

        return false;
    }

    private bool IsRelatedNode(NodeSummary node)
    {
        if (!HasHover)
        {
            return false;
        }

        var pod = GetHoveredPod();
        if (pod is not null)
        {
            return string.Equals(pod.Node, node.Name, StringComparison.Ordinal);
        }

        return VisiblePods.Any(visiblePod =>
            IsRelatedPod(visiblePod) &&
            string.Equals(visiblePod.Node, node.Name, StringComparison.Ordinal));
    }

    private static HashSet<string> GetIngressServiceNames(IngressSummary ingress)
        => ingress.Rules
            .Select(rule => rule.Backend.ServiceName)
            .Where(name => !string.IsNullOrWhiteSpace(name))
            .ToHashSet(StringComparer.Ordinal);

    private bool IsIngressRelatedToWorkload(IngressSummary ingress, WorkloadSummary workload)
    {
        if (ingress.Namespace != workload.Namespace)
        {
            return false;
        }

        var serviceNames = GetIngressServiceNames(ingress);
        if (serviceNames.Count == 0)
        {
            return false;
        }

        return GetWorkloadServices(workload).Any(service => serviceNames.Contains(service.Name));
    }

    private bool IsIngressRelatedToPod(IngressSummary ingress, PodSummary pod)
    {
        if (ingress.Namespace != pod.Namespace)
        {
            return false;
        }

        var serviceNames = GetIngressServiceNames(ingress);
        if (serviceNames.Count == 0)
        {
            return false;
        }

        return VisibleServices.Any(service =>
            service.Namespace == pod.Namespace &&
            serviceNames.Contains(service.Name) &&
            LabelsMatch(service.Selector, pod.Labels));
    }

    private void UpdateLastUpdatedClock()
    {
        LastUpdatedCts?.Cancel();
        LastUpdatedCts = new CancellationTokenSource();
        _ = RunLastUpdatedClockAsync(LastUpdatedCts.Token);
    }

    private async Task RunLastUpdatedClockAsync(CancellationToken ct)
    {
        using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        while (await timer.WaitForNextTickAsync(ct))
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void MarkInteraction()
    {
        _lastInteractionAt = DateTimeOffset.UtcNow;
    }

    private void ToggleWorkload(WorkloadSummary workload)
    {
        MarkInteraction();
        var key = GetWorkloadKey(workload);
        SelectedWorkloadKey = SelectedWorkloadKey == key ? null : key;
    }

    private async Task RestartWorkload(WorkloadSummary workload)
    {
        MarkInteraction();
        var key = GetWorkloadKey(workload);
        if (Restarting.Contains(key))
        {
            return;
        }

        var confirmed = await Js.InvokeAsync<bool>(
            "confirm",
            $"Restart {workload.Kind} {workload.Name} in {workload.Namespace}?");
        if (!confirmed)
        {
            return;
        }

        Restarting.Add(key);
        ActionMessage = null;

        try
        {
            var requestUri = BuildRequestUri($"/cluster/workloads/{Uri.EscapeDataString(workload.Kind)}/{Uri.EscapeDataString(workload.Namespace)}/{Uri.EscapeDataString(workload.Name)}/restart");
            using var response = await Http.PostAsync(requestUri, null);
            ActionMessage = response.IsSuccessStatusCode
                ? $"Restarted {workload.Kind} {workload.Name} in {workload.Namespace}."
                : $"Failed to restart {workload.Kind} {workload.Name}: HTTP {(int)response.StatusCode}.";
        }
        catch (Exception ex)
        {
            ActionMessage = ex.Message;
        }
        finally
        {
            Restarting.Remove(key);
        }
    }

    private static string GetWorkloadKey(WorkloadSummary workload)
        => $"{workload.Kind}:{workload.Namespace}/{workload.Name}";

    private async Task OpenLogs(PodSummary pod)
    {
        MarkInteraction();
        IsLogModalOpen = true;
        LogLoading = true;
        LogError = null;
        LogContent = null;
        LogContentRaw = null;
        LogTitle = pod.Name;
        LogSubtitle = $"{pod.Namespace} · {pod.Node}";

        try
        {
            var requestUri = BuildRequestUri($"/cluster/pods/{Uri.EscapeDataString(pod.Namespace)}/{Uri.EscapeDataString(pod.Name)}/logs?tail=200");
            LogContentRaw = await Http.GetStringAsync(requestUri);
            LogContent = BuildLogMarkup(LogContentRaw, LogFilter);
        }
        catch (Exception ex)
        {
            LogError = ex.Message;
        }
        finally
        {
            LogLoading = false;
        }

        UpdateLogFollow();
    }

    private void CloseLogs()
    {
        MarkInteraction();
        IsLogModalOpen = false;
        LogContent = null;
        LogContentRaw = null;
        LogError = null;
        LogFollowCts?.Cancel();
    }

    private void OnLogFilterChanged()
    {
        LogContent = BuildLogMarkup(LogContentRaw, LogFilter);
    }

    private void UpdateLogFollow()
    {
        LogFollowCts?.Cancel();
        if (!IsLogModalOpen)
        {
            return;
        }

        LogFollowCts = new CancellationTokenSource();
        _ = RunLogFollowAsync(LogFollowCts.Token);
    }

    private async Task RunLogFollowAsync(CancellationToken ct)
    {
        using var timer = new PeriodicTimer(TimeSpan.FromSeconds(LogRefreshSeconds));
        while (await timer.WaitForNextTickAsync(ct))
        {
            await RefreshLogs(ct);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RefreshLogs(CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(LogTitle) || string.IsNullOrWhiteSpace(LogSubtitle))
        {
            return;
        }

        var showLoading = LogContentRaw is null;
        if (showLoading)
        {
            LogLoading = true;
        }
        LogError = null;
        try
        {
            var parts = LogSubtitle.Split(" · ");
            var ns = parts.Length > 0 ? parts[0] : "";
            if (string.IsNullOrWhiteSpace(ns))
            {
                return;
            }

            var requestUri = BuildRequestUri($"/cluster/pods/{Uri.EscapeDataString(ns)}/{Uri.EscapeDataString(LogTitle)}/logs?tail=200");
            LogContentRaw = await Http.GetStringAsync(requestUri, ct);
            LogContent = BuildLogMarkup(LogContentRaw, LogFilter);
        }
        catch (Exception ex)
        {
            LogError = ex.Message;
        }
        finally
        {
            if (showLoading)
            {
                LogLoading = false;
            }
        }
    }

    private IEnumerable<ServiceSummary> GetWorkloadServices(WorkloadSummary workload)
        => VisibleServices.Where(service =>
            service.Namespace == workload.Namespace &&
            LabelsMatch(service.Selector, workload.Labels));

    private IEnumerable<PodSummary> GetWorkloadPods(WorkloadSummary workload)
        => VisiblePods.Where(pod =>
            pod.Namespace == workload.Namespace &&
            LabelsMatch(workload.Labels, pod.Labels));

    private IEnumerable<IngressSummary> GetWorkloadIngresses(IReadOnlyList<ServiceSummary> services)
    {
        if (services.Count == 0)
        {
            return Enumerable.Empty<IngressSummary>();
        }

        var serviceKeys = new HashSet<string>(services.Select(service => $"{service.Namespace}/{service.Name}"));
        return VisibleIngresses.Where(ingress =>
            ingress.Rules.Any(rule => serviceKeys.Contains($"{ingress.Namespace}/{rule.Backend.ServiceName}")));
    }

    private static bool LabelsMatch(IReadOnlyDictionary<string, string> selector, IReadOnlyDictionary<string, string> labels)
    {
        if (selector.Count == 0 || labels.Count == 0)
        {
            return false;
        }

        return selector.All(label =>
            labels.TryGetValue(label.Key, out var value) &&
            string.Equals(value, label.Value, StringComparison.Ordinal));
    }

    private async Task<T?> GetFromApiAsync<T>(string path)
    {
        var requestUri = BuildRequestUri(path);
        return await Http.GetFromJsonAsync<T>(requestUri);
    }

    private Uri BuildRequestUri(string path)
    {
        var baseUrl = Configuration["SelfBaseUrl"];
        var baseUri = string.IsNullOrWhiteSpace(baseUrl)
            ? new Uri(Navigation.BaseUri)
            : new Uri(baseUrl, UriKind.Absolute);
        return new Uri(baseUri, path);
    }

    private string? GetIngressOpenUrl(IngressSummary ingress)
    {
        var rule = ingress.Rules.FirstOrDefault(r => !string.IsNullOrWhiteSpace(r.Host));
        if (rule is not null)
        {
            var path = string.IsNullOrWhiteSpace(rule.Path) ? "/" : rule.Path;
            return $"http://{rule.Host}{path}";
        }

        return ingress.ExternalUrls.FirstOrDefault();
    }

    private string? GetServiceOpenUrl(ServiceSummary service)
    {
        var nodePort = service.Ports.FirstOrDefault(p => p.NodePort is not null)?.NodePort;
        if (nodePort is null)
        {
            return null;
        }

        var node = Nodes.FirstOrDefault();
        if (node is null)
        {
            return null;
        }

        var host = !string.IsNullOrWhiteSpace(node.ExternalIp) ? node.ExternalIp : node.InternalIp;
        if (string.IsNullOrWhiteSpace(host))
        {
            return null;
        }

        return $"http://{host}:{nodePort}";
    }

    private IReadOnlyList<WorkloadSummary> VisibleWorkloads
        => Workloads;

    private IReadOnlyList<ServiceSummary> VisibleServices
        => Services;

    private IReadOnlyList<PodSummary> VisiblePods
        => Pods;

    private IReadOnlyList<IngressSummary> VisibleIngresses
        => Ingresses;

    private static string FormatPorts(IReadOnlyList<ServicePortSummary> ports)
    {
        if (ports.Count == 0)
        {
            return "";
        }

        return string.Join(", ", ports.Select(p =>
        {
            var target = p.TargetPort is null ? "" : $"->{p.TargetPort}";
            var node = p.NodePort is null ? "" : $" (node {p.NodePort})";
            return $"{p.Port}{target}{node}/{p.Protocol}";
        }));
    }

    private static string FormatLabels(IReadOnlyDictionary<string, string> labels)
    {
        if (labels.Count == 0)
        {
            return "";
        }

        return string.Join(", ", labels.Select(label => $"{label.Key}={label.Value}"));
    }

    private static string FormatRelatedSummary(int services, int pods, int ingresses)
        => $"{services} svc · {pods} pods · {ingresses} ing";

    private static string FormatWorkloadStatus(WorkloadSummary workload)
    {
        var desired = FormatNullable(workload.Desired);
        var ready = FormatNullable(workload.Ready);
        return $"{ready}/{desired}";
    }

    private static string GetStatusBadgeClass(string status)
    {
        var normalized = status.ToLowerInvariant();
        if (normalized.Contains("running") || normalized.Contains("ready") || normalized.Contains("completed"))
        {
            return "status-success";
        }

        if (normalized.Contains("pending") || normalized.Contains("creating") || normalized.Contains("progress"))
        {
            return "status-warning";
        }

        if (normalized.Contains("crash") || normalized.Contains("error") || normalized.Contains("failed") ||
            normalized.Contains("backoff") || normalized.Contains("unknown"))
        {
            return "status-danger";
        }

        return "status-neutral";
    }

    private static string GetStatusBadgeLabel(string status)
    {
        var normalized = status.ToLowerInvariant();
        if (normalized.Contains("running") || normalized.Contains("ready") || normalized.Contains("completed"))
        {
            return "ok";
        }

        if (normalized.Contains("pending") || normalized.Contains("creating") || normalized.Contains("progress"))
        {
            return "warn";
        }

        if (normalized.Contains("crash") || normalized.Contains("error") || normalized.Contains("failed") ||
            normalized.Contains("backoff") || normalized.Contains("unknown"))
        {
            return "err";
        }

        return "info";
    }

    private static string GetWorkloadTagClass(string kind)
        => kind.ToLowerInvariant() switch
        {
            "deployment" => "tag-deploy",
            "statefulset" => "tag-sts",
            "stateful set" => "tag-sts",
            "sts" => "tag-sts",
            "daemonset" => "tag-ds",
            _ => "tag-deploy"
        };

    private static string FormatIngressRules(IReadOnlyList<IngressRuleSummary> rules)
    {
        if (rules.Count == 0)
        {
            return "";
        }

        return string.Join("; ", rules.Select(rule =>
        {
            var backend = string.IsNullOrWhiteSpace(rule.Backend.ServiceName)
                ? ""
                : $"{rule.Backend.ServiceName}{(rule.Backend.ServicePort is null ? "" : $":{rule.Backend.ServicePort}")}";
            var host = string.IsNullOrWhiteSpace(rule.Host) ? "*" : rule.Host;
            var path = string.IsNullOrWhiteSpace(rule.Path) ? "/" : rule.Path;
            return $"{host}{path} → {backend}";
        }));
    }

    private static string FormatIngressHost(IngressSummary ingress)
    {
        var rule = ingress.Rules.FirstOrDefault(r => !string.IsNullOrWhiteSpace(r.Host));
        return rule?.Host ?? "-";
    }

    private static string FormatNullable(int? value) => value?.ToString() ?? "-";

    private static string BuildLogMarkup(string? content, string? filter)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return string.Empty;
        }

        var encoded = System.Net.WebUtility.HtmlEncode(content);

        if (string.IsNullOrWhiteSpace(filter))
        {
            return encoded;
        }

        var filterEncoded = System.Net.WebUtility.HtmlEncode(filter);
        var pattern = System.Text.RegularExpressions.Regex.Escape(filterEncoded);
        return System.Text.RegularExpressions.Regex.Replace(
            encoded,
            pattern,
            match => $"<mark>{match.Value}</mark>",
            System.Text.RegularExpressions.RegexOptions.IgnoreCase);
    }

    public ValueTask DisposeAsync()
    {
        if (_clusterHub is not null)
        {
            _ = _clusterHub.DisposeAsync();
        }
        LogFollowCts?.Cancel();
        LastUpdatedCts?.Cancel();
        LayoutState.ClearHeaderContent(HeaderContent);
        return ValueTask.CompletedTask;
    }

    private string LastUpdatedLabel
        => LastUpdatedAt is null
            ? "Last refresh -"
            : $"Last refresh {FormatRelativeTime(LastUpdatedAt.Value)}";

    private static string FormatRelativeTime(DateTimeOffset timestamp)
    {
        var elapsed = DateTimeOffset.Now - timestamp;
        if (elapsed.TotalSeconds < 60)
        {
            var seconds = Math.Max(1, (int)elapsed.TotalSeconds);
            return $"{seconds}s ago";
        }

        if (elapsed.TotalMinutes < 60)
        {
            var minutes = (int)elapsed.TotalMinutes;
            return $"{minutes}m ago";
        }

        var hours = (int)elapsed.TotalHours;
        return $"{hours}h ago";
    }

    private RenderFragment HeaderContent => @<section class="controls">
        <div class="controls-left">
            <span class="meta">@LastUpdatedLabel</span>
        </div>
        <div class="controls-right"></div>
    </section>;
}
